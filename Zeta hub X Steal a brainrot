-- Game Restriction: Only works on Steal a Brainrot
if game.PlaceId ~= 109983668079237 then
    game:GetService("Players").LocalPlayer:Kick("Please join Steal a Brainrot")
    return
end

-- Anti-Kick and Crash Protection
pcall(function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local mt = getrawmetatable(game)
    local gameShuttingDown = false

    game:BindToClose(function() gameShuttingDown = true end)
    
    if setreadonly then setreadonly(mt, false) end
    
    local oldNamecall = mt.__namecall
    local oldIndex = mt.__index
    
    mt.__namecall = newcclosure(function(self, ...)
        if gameShuttingDown then return oldNamecall(self, ...) end
        local method = getnamecallmethod()
        if typeof(method) == "string" and method:lower() == "kick" then
            warn("Kick attempt blocked via __namecall")
            return nil
        end
        return oldNamecall(self, ...)
    end)
    
    mt.__index = newcclosure(function(self, key)
        if gameShuttingDown then return oldIndex(self, key) end
        if typeof(key) == "string" then
            local lowered = key:lower()
            if lowered == "kick" then
                warn("Kick attempt blocked via __index")
                return function() end
            elseif (lowered == "breakjoints" or lowered == "destroy") then
                warn("Destructive method '" .. key .. "' blocked via __index")
                return function() end
            end
        end
        return oldIndex(self, key)
    end)
    
    if LocalPlayer then
        local originalKick = LocalPlayer.Kick
        LocalPlayer.Kick = function(self, ...)
            if not gameShuttingDown then
                warn("Kick attempt blocked via .Kick override")
                return nil
            end
            return originalKick(self, ...)
        end
    end
    
    local function protectCharacter(char)
        if not char then return end
        
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                local originalDestroy = part.Destroy
                part.Destroy = function(self, ...)
                    if not gameShuttingDown then
                        warn("Attempted to destroy character part: " .. part.Name)
                        return nil
                    end
                    return originalDestroy(self, ...)
                end
            end
        end
        
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if hum then
            hum.BreakJointsOnDeath = false
        end
    end
    
    if LocalPlayer.Character then
        protectCharacter(LocalPlayer.Character)
    end
    
    LocalPlayer.CharacterAdded:Connect(protectCharacter)
    
    if setreadonly then setreadonly(mt, true) end
end)

-- Load RedzLib
local success, redzlib = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/tbao143/Library-ui/refs/heads/main/Redzhubui"))()
end)

if not success then
    warn("Failed to load RedzLib:", redzlib)
    return
end

-- Create Window
local Window = redzlib:MakeWindow({
    Title = "Zeta Hub X Steal a Brainrot",
    SubTitle = "by SILENT",
    SaveFolder = "ZetaHubUniversal"
})

Window:AddMinimizeButton({
    Button = { Image = "rbxassetid://100006760882280", BackgroundTransparency = 0 },
    Corner = { CornerRadius = UDim.new(0, 6) },
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

-- Player and References
local LocalPlayer = Players.LocalPlayer
local character, humanoid
local markedLocation = nil
local baseBlockLocation = nil

local function updateReferences()
    character = LocalPlayer.Character
    humanoid = character and character:FindFirstChildOfClass("Humanoid") or nil
end

LocalPlayer.CharacterAdded:Connect(updateReferences)
LocalPlayer.CharacterRemoving:Connect(function()
    character = nil
    humanoid = nil
end)

updateReferences()

-- Discord Tab
local TabDiscord = Window:MakeTab({ Title = "Discord", Icon = "rbxassetid://84198990394879" })
TabDiscord:AddSection("Discord")
TabDiscord:AddDiscordInvite({
    Name = "Zeta Hub",
    Description = "Join the community",
    Logo = "rbxassetid://88800066762467",
    Invite = "https://discord.gg/pzrtAEDBbt"
})

-- Security Tab
local TabSecurity = Window:MakeTab({ Title = "Security", Icon = "rbxassetid://139126357881607" })
TabSecurity:AddSection("Base Tools")

TabSecurity:AddButton({
    Title = "Mark Base Block Location",
    Description = "Save your current position as a base block reference",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp then
            baseBlockLocation = hrp.Position
            print("Base block location marked at:", baseBlockLocation)
        else
            warn("HumanoidRootPart not found")
        end
    end
})

TabSecurity:AddButton({
    Title = "Teleport to Base Block",
    Description = "Teleport to the saved base block location",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp and baseBlockLocation then
            hrp.CFrame = CFrame.new(baseBlockLocation)
            print("Teleported to base block")
        else
            warn("Missing HumanoidRootPart or no location marked")
        end
    end
})

TabSecurity:AddButton({
    Title = "Teleport to Your Side Base",
    Description = "Teleport to the PlotBlock of the current base you're inside",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local sideModel = nil
        for _, base in pairs(workspace:GetChildren()) do
            if base:IsA("Model") and base.Name:match("^%d+ Side$") then
                if character:IsDescendantOf(base) then
                    sideModel = base
                    break
                end
            end
        end
        
        if sideModel then
            local plot = sideModel:FindFirstChild("PlotBlock", true)
            if plot then
                hrp.CFrame = plot.CFrame + Vector3.new(0, 5, 0)
                print("Teleported to PlotBlock:", sideModel.Name)
            else
                warn("PlotBlock not found in", sideModel.Name)
            end
        else
            warn("No base detected")
        end
    end
})

-- Main Tab
local TabMain = Window:MakeTab({ Title = "Main", Icon = "rbxassetid://106319096400681" })
TabMain:AddSection("Movement")

TabMain:AddButton({
    Title = "Mark Location",
    Description = "Saves your current position for teleport",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if hrp then
            markedLocation = hrp.Position
            print("Marked location at:", markedLocation)
        else
            warn("HumanoidRootPart not found")
        end
    end
})

TabMain:AddButton({
    Title = "Tween Teleport to Marked Location",
    Description = "Smooth teleport with wall pass and damage immunity",
    Callback = function()
        updateReferences()
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not hrp or not humanoid or not markedLocation then return end

        local originalHealth = humanoid.Health
        local immune = true
        
        local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            if immune and humanoid.Health < originalHealth then
                humanoid.Health = originalHealth
            end
        end)
        
        local affectedParts = {}
        for _, part in ipairs(character:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                table.insert(affectedParts, { part = part, t = part.Transparency, c = part.CanCollide })
                part.Transparency = 1
                part.CanCollide = false
            elseif part:IsA("Decal") then
                part.Transparency = 1
            end
        end
        
        local removedWalls = {}
        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name:lower():find("wall") then
                table.insert(removedWalls, { part = obj, t = obj.Transparency, c = obj.CanCollide })
                obj.Transparency = 1
                obj.CanCollide = false
            end
        end
        
        local dist = (hrp.Position - markedLocation).Magnitude
        local tweenInfo = TweenInfo.new(dist / 40, Enum.EasingStyle.Linear)
        local tween = TweenService:Create(hrp, tweenInfo, { CFrame = CFrame.new(markedLocation + Vector3.new(0, 3, 0)) })
        
        tween:Play()
        tween.Completed:Connect(function()
            immune = false
            if healthConn then healthConn:Disconnect() end
            
            for _, data in ipairs(affectedParts) do
                if data.part and data.part.Parent then
                    data.part.Transparency = data.t
                    data.part.CanCollide = data.c
                end
            end
            
            for _, data in ipairs(removedWalls) do
                if data.part and data.part.Parent then
                    data.part.Transparency = data.t
                    data.part.CanCollide = data.c
                end
            end
        end)
    end
})

-- Anti-Ragdoll
local antiRagdollEnabled = false
local antiRagdollConnection

TabMain:AddSection("Anti-Ragdoll")
TabMain:AddToggle({
    Title = "Anti-Ragdoll",
    Description = "Prevents your character from turning into ragdoll",
    Default = false,
    Callback = function(state)
        antiRagdollEnabled = state
        if state then
            warn("Anti-Ragdoll enabled")
            antiRagdollConnection = RunService.Heartbeat:Connect(function()
                updateReferences()
                if not character then return end
                
                for _, limb in ipairs({"Left Arm", "Right Arm", "Left Leg", "Right Leg", "Head", "Torso", "UpperTorso", "LowerTorso"}) do
                    local part = character:FindFirstChild(limb)
                    if part then
                        for _, c in ipairs(part:GetChildren()) do
                            if c:IsA("BallSocketConstraint") or c:IsA("HingeConstraint") then
                                c:Destroy()
                            end
                        end
                    end
                end
                
                for _, joint in ipairs(character:GetDescendants()) do
                    if joint:IsA("Motor6D") then
                        joint.Enabled = true
                    end
                end
            end)
        else
            warn("Anti-Ragdoll disabled")
            if antiRagdollConnection then
                antiRagdollConnection:Disconnect()
                antiRagdollConnection = nil
            end
        end
    end
})

-- Functions Tab
local TabFunctions = Window:MakeTab({ Title = "Functions", Icon = "rbxassetid://103306413269388" })

-- Infinite Jump
local infiniteJumpEnabled = false
local jumpConnection

local function handleJump()
    updateReferences()
    if humanoid and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end

TabFunctions:AddToggle({
    Title = "Infinite Jump",
    Description = "Allows you to jump infinitely in mid-air",
    Default = false,
    Callback = function(state)
        infiniteJumpEnabled = state
        if state then
            warn("Infinite Jump enabled")
            if jumpConnection then jumpConnection:Disconnect() end
            jumpConnection = UserInputService.JumpRequest:Connect(handleJump)
            
            LocalPlayer.CharacterAdded:Connect(function()
                updateReferences()
                if infiniteJumpEnabled then
                    if jumpConnection then jumpConnection:Disconnect() end
                    jumpConnection = UserInputService.JumpRequest:Connect(handleJump)
                end
            end)
        else
            warn("Infinite Jump disabled")
            if jumpConnection then
                jumpConnection:Disconnect()
                jumpConnection = nil
            end
        end
    end
})

-- NoClip
local noClipEnabled = false
local noClipConnection

local function noclipLoop()
    updateReferences()
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
end

TabFunctions:AddToggle({
    Title = "NoClip",
    Description = "Allows you to walk through walls",
    Default = false,
    Callback = function(state)
        noClipEnabled = state
        if state then
            warn("NoClip enabled")
            noClipConnection = RunService.Stepped:Connect(noclipLoop)
        else
            warn("NoClip disabled")
            if noClipConnection then
                noClipConnection:Disconnect()
                noClipConnection = nil
            end
        end
    end
})

-- ESP Players (Persistent across deaths)
local espEnabled = false
local espFolders = {}
local espConnections = {}

local function createESP(player)
    if player == Players.LocalPlayer then return end

    local function setup()
        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
        
        -- Remove existing ESP
        if espFolders[player] then
            espFolders[player]:Destroy()
        end
        if espConnections[player] then
            for _, conn in pairs(espConnections[player]) do
                pcall(function() conn:Disconnect() end)
            end
            espConnections[player] = {}
        end
        
        local folder = Instance.new("Folder")
        folder.Name = "ESP" .. player.Name
        folder.Parent = workspace
        espFolders[player] = folder
        
        local highlight = Instance.new("Highlight")
        highlight.Adornee = player.Character
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.Parent = folder
        
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = player.Character:FindFirstChild("HumanoidRootPart")
        billboard.Size = UDim2.new(0, 200, 0, 40)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.MaxDistance = 1000
        billboard.Parent = folder
        
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextStrokeTransparency = 0.5
        textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        textLabel.TextSize = 14
        textLabel.Font = Enum.Font.GothamBold
        textLabel.Text = player.Name
        textLabel.TextColor3 = Color3.new(1, 1, 1)
        textLabel.Parent = billboard
        
        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local function updateText()
                textLabel.Text = string.format("%s [%d/%d]", player.Name, math.floor(humanoid.Health), math.floor(humanoid.MaxHealth))
            end
            updateText()
            
            if not espConnections[player] then
                espConnections[player] = {}
            end
            espConnections[player].healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(updateText)
        end
        
        if not espConnections[player] then
            espConnections[player] = {}
        end
        espConnections[player].renderConn = RunService.RenderStepped:Connect(function()
            local hue = tick() % 5 / 5
            local color = Color3.fromHSV(hue, 1, 1)
            textLabel.TextColor3 = color
            highlight.FillColor = color
            highlight.OutlineColor = color
        end)
    end
    
    setup()
    
    -- Ensure ESP persists across character respawns
    if not espConnections[player] then
        espConnections[player] = {}
    end
    espConnections[player].charAdded = player.CharacterAdded:Connect(function()
        task.wait(0.5)
        if espEnabled then
            setup()
        end
    end)
end

local function updateESP()
    for player, folder in pairs(espFolders) do
        if folder then folder:Destroy() end
    end
    for player, conns in pairs(espConnections) do
        for _, conn in pairs(conns) do
            pcall(function() conn:Disconnect() end)
        end
    end
    espFolders = {}
    espConnections = {}

    if espEnabled then
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= Players.LocalPlayer then
                createESP(player)
            end
        end
    end
end

-- ESP stays active after local player death
local espPlayerAddedConnection
local espLocalPlayerRespawnConnection

TabFunctions:AddToggle({
    Title = "ESP Players",
    Description = "Highlights players with RGB + name and health (Persistent)",
    Default = false,
    Callback = function(state)
        espEnabled = state
        if state then
            warn("ESP enabled")
            updateESP()
            
            -- Handle new players joining
            if espPlayerAddedConnection then espPlayerAddedConnection:Disconnect() end
            espPlayerAddedConnection = Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function()
                    task.wait(0.5)
                    if espEnabled then
                        createESP(player)
                    end
                end)
            end)
            
            -- Ensure ESP stays active after local player respawns
            if espLocalPlayerRespawnConnection then espLocalPlayerRespawnConnection:Disconnect() end
            espLocalPlayerRespawnConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1)
                if espEnabled then
                    updateESP()
                end
            end)
        else
            warn("ESP disabled")
            updateESP()
            if espPlayerAddedConnection then espPlayerAddedConnection:Disconnect() end
            if espLocalPlayerRespawnConnection then espLocalPlayerRespawnConnection:Disconnect() end
        end
    end
})

-- Enhanced GodMode with better protection
local godModeEnabled = false
local godModeConnection
local godModeHealthConnection

TabFunctions:AddToggle({
    Title = "GodMode",
    Description = "Advanced god mode with multiple protection layers",
    Default = false,
    Callback = function(state)
        godModeEnabled = state
        if state then
            warn("GodMode enabled")
            
            local function setupGodMode()
                updateReferences()
                if not humanoid then return end
                
                -- Store original max health
                local originalMaxHealth = humanoid.MaxHealth
                
                -- Health monitoring
                if godModeHealthConnection then godModeHealthConnection:Disconnect() end
                godModeHealthConnection = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                    if godModeEnabled and humanoid.Health < originalMaxHealth then
                        humanoid.Health = originalMaxHealth
                    end
                end)
                
                -- Prevent death state
                local stateConnection = humanoid:GetPropertyChangedSignal("PlatformStand"):Connect(function()
                    if godModeEnabled then
                        humanoid.PlatformStand = false
                    end
                end)
                
                -- Monitor for death and restore
                local deathConnection = humanoid.Died:Connect(function()
                    if godModeEnabled then
                        task.wait(0.1)
                        if humanoid and humanoid.Parent then
                            humanoid:ChangeState(Enum.HumanoidStateType.Running)
                            humanoid.Health = originalMaxHealth
                        end
                    end
                end)
                
                -- Store connections for cleanup
                if not espConnections.godMode then
                    espConnections.godMode = {}
                end
                espConnections.godMode.health = godModeHealthConnection
                espConnections.godMode.state = stateConnection
                espConnections.godMode.death = deathConnection
            end
            
            -- Main godmode loop
            godModeConnection = RunService.Heartbeat:Connect(function()
                updateReferences()
                if not character or not humanoid then return end
                
                -- Force health to max
                if humanoid.Health < humanoid.MaxHealth then
                    humanoid.Health = humanoid.MaxHealth
                end
                
                -- Prevent death state
                if humanoid:GetState() == Enum.HumanoidStateType.Dead then
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    humanoid.Health = humanoid.MaxHealth
                end
                
                -- Remove damage effects
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        -- Remove fire, smoke, or other damage effects
                        for _, effect in ipairs(part:GetChildren()) do
                            if effect:IsA("Fire") or effect:IsA("Smoke") or effect:IsA("Sparkles") then
                                effect:Destroy()
                            end
                        end
                    end
                end
            end)
            
            -- Setup for current character
            setupGodMode()
            
            -- Re-setup on character respawn
            LocalPlayer.CharacterAdded:Connect(function()
                task.wait(0.5)
                if godModeEnabled then
                    setupGodMode()
                end
            end)
            
        else
            warn("GodMode disabled")
            if godModeConnection then
                godModeConnection:Disconnect()
                godModeConnection = nil
            end
            if godModeHealthConnection then
                godModeHealthConnection:Disconnect()
                godModeHealthConnection = nil
            end
            if espConnections.godMode then
                for _, conn in pairs(espConnections.godMode) do
                    pcall(function() conn:Disconnect() end)
                end
                espConnections.godMode = nil
            end
        end
    end
})

-- Cleanup on script end
game:BindToClose(function()
    for player, folder in pairs(espFolders) do
        if folder then folder:Destroy() end
    end
    for player, conns in pairs(espConnections) do
        for _, conn in pairs(conns) do
            pcall(function() conn:Disconnect() end)
        end
    end
end)
